// Package loadbalancers provides a the CRUD operations for locations
package loadbalancers

import (
	"context"
	"errors"
	"net/http"
	"testing"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/volatiletech/null/v8"
	"go.uber.org/zap"

	"go.infratographer.com/loadbalancerapi/internal/dbtools"
	"go.infratographer.com/loadbalancerapi/internal/httptools"
	"go.infratographer.com/loadbalancerapi/internal/models"
	errorsx "go.infratographer.com/loadbalancerapi/pkg/api/v1"
	"go.infratographer.com/loadbalancerapi/pkg/api/v1/types"
)


func TestNewLoadBalancer(t *testing.T) {
	tenantID := uuid.New()
	locationID := uuid.New()


	type args struct {
		c *gin.Context
	}

	tests := []struct {
		name    string
		args    args
		want    *LoadBalancer
		wantErr bool
		err     error
	}{
		{
			name: "Happy path",
			args: args{
				c: &[]gin.Context{
					{
						Request: &http.Request{
							Body: httptools.FakeBody(happyPathBody),
						},
					},
				}[0],
			},
			want: &LoadBalancer{
				Object: &types.LoadBalancer{
					TenantID:   tenantID,
					LocationID: locationID,
					IPAddress:  "1.1.1.1",
					Name:       "Nemo",
					Size:       "small",
					Type:       "layer-3",
				},
			},
			wantErr: false,
		},
		{
			name: "Missing display name",
			args: args{
				c: &[]gin.Context{
					{
						Request: &http.Request{
							Body: httptools.FakeBody(missingDisplayNameBody),
						},
					},
				}[0],
			},
			err:     errorsx.ErrNameRequired,
			wantErr: true,
		},
		{
			name: "Missing tenant ID",
			args: args{
				c: &[]gin.Context{
					{
						Request: &http.Request{
							Body: httptools.FakeBody(missingTenantIDBody),
						},
					},
				}[0],
			},
			err:     errorsx.ErrTenantIDRequired,
			wantErr: true,
		},
		{
			name: "Missing location ID",
			args: args{
				c: &[]gin.Context{
					{
						Request: &http.Request{
							Body: httptools.FakeBody(missingLocationIDBody),
						},
					},
				}[0],
			},
			err:     errorsx.ErrLocationIDRequired,
			wantErr: true,
		},
		{
			name: "Missing size",
			args: args{
				c: &[]gin.Context{
					{
						Request: &http.Request{
							Body: httptools.FakeBody(missingSizeBody),
						},
					},
				}[0],
			},
			err:     errorsx.ErrSizeRequired,
			wantErr: true,
		},
		{
			name: "Missing type",
			args: args{
				c: &[]gin.Context{
					{
						Request: &http.Request{
							Body: httptools.FakeBody(missingTypeBody),
						},
					},
				}[0],
			},
			err:     errorsx.ErrTypeRequired,
			wantErr: true,
		},
		{
			name: "Invalid type",
			args: args{
				c: &[]gin.Context{
					{
						Request: &http.Request{
							Body: httptools.FakeBody(invalidTypeBody),
						},
					},
				}[0],
			},
			err:     errorsx.ErrTypeInvalid,
			wantErr: true,
		},
		{
			name: "Bad IP address",
			args: args{
				c: &[]gin.Context{
					{
						Request: &http.Request{
							Body: httptools.FakeBody(badIPAddressBody),
						},
					},
				}[0],
			},
			err:     errorsx.ErrIPAddressInvalid,
			wantErr: true,
		},
		{
			name: "IPv6",
			args: args{
				c: &[]gin.Context{
					{
						Request: &http.Request{
							Body: httptools.FakeBody(ipv6Body),
						},
					},
				}[0],
			},
			err:     errorsx.ErrIPv4Required,
			wantErr: true,
		},
		{
			name: "Bad body",
			args: args{
				c: &[]gin.Context{
					{
						Request: &http.Request{
							Body: httptools.FakeBody(badBody),
						},
					},
				}[0],
			},
			// encoding/json implements its own SyntaxError type, so we can't use it here.
			err:     errors.New("invalid character 'b' looking for beginning of value"), //nolint:goerr113
			wantErr: true,
		},
	}

	for _, tt := range tests {
		got, err := NewLoadBalancer(tt.args.c)
		if tt.wantErr {
			assert.NotNil(t, err)
			assert.ErrorContains(t, err, tt.err.Error())
		} else {
			assert.Nil(t, err)
			assert.Equal(t, tt.want, got)
		}
	}
}

func TestLoadBalancer_ToDBModel(t *testing.T) {
	LoadBalancerID := uuid.New()
	locationID := uuid.New()
	now := time.Now()
	tenantID := uuid.New()

	type fields struct {
		CreatedAt  time.Time
		UpdatedAt  time.Time
		DeletedAt  *null.Time
		ID         uuid.UUID
		TenantID   uuid.UUID
		IPAddress  string
		Name       string
		LocationID uuid.UUID
		Size       string
		Type       string
	}

	tests := []struct {
		name    string
		fields  fields
		want    *models.LoadBalancer
		wantErr bool
		err     error
	}{
		{
			name: "Happy path",
			fields: fields{
				CreatedAt:  now,
				UpdatedAt:  now,
				DeletedAt:  &null.Time{},
				LocationID: locationID,
				ID:         LoadBalancerID,
				Name:       "Bruce",
				Size:       "small",
				Type:       "layer-3",
				TenantID:   tenantID,
				IPAddress:  "1.1.1.1",
			},
			want: &models.LoadBalancer{
				CreatedAt:        now,
				UpdatedAt:        now,
				DeletedAt:        null.Time{},
				DisplayName:      "Bruce",
				LoadBalancerID:   LoadBalancerID.String(),
				LocationID:       locationID.String(),
				LoadBalancerSize: "small",
				LoadBalancerType: "layer-3",
				TenantID:         tenantID.String(),
				IPAddr:           "1.1.1.1",
			},
			wantErr: false,
		},
		{
			name: "Invalid LoadBalancer struct to DB model",
			fields: fields{
				CreatedAt:  now,
				UpdatedAt:  now,
				DeletedAt:  &null.Time{},
				LocationID: locationID,
				Name:       "Bruce",
				Size:       "small",
				Type:       "layer-3",
				TenantID:   tenantID,
			},
			wantErr: true,
			err:     errorsx.ErrIPAddressRequired,
		},
	}

	for _, tt := range tests {
		lb := &LoadBalancer{
			Object: &types.LoadBalancer{
				CreatedAt:  tt.fields.CreatedAt,
				UpdatedAt:  tt.fields.UpdatedAt,
				DeletedAt:  tt.fields.DeletedAt,
				ID:         tt.fields.ID,
				TenantID:   tt.fields.TenantID,
				IPAddress:  tt.fields.IPAddress,
				Name:       tt.fields.Name,
				LocationID: tt.fields.LocationID,
				Size:       tt.fields.Size,
				Type:       tt.fields.Type,
			},
		}

		got, err := lb.ToDBModel()
		if tt.wantErr {
			assert.NotNil(t, err)
			assert.ErrorContains(t, err, tt.err.Error())
		} else {
			assert.Nil(t, err)
			assert.Equal(t, tt.want.TenantID, got.TenantID)
			assert.Equal(t, tt.want.DisplayName, got.DisplayName)
		}
	}
}

func TestLoadBalancer_DB(t *testing.T) {
	ctx := context.Background()
	db := dbtools.DatabaseTest(t)

	loc1, loc1CleanUp := CreateTestLocation(t, db)
	defer loc1CleanUp()

	lb1, lb1CleanUp := CreateTestLoadBalancer(t, db, loc1.Object.ID)
	defer lb1CleanUp()

	err := lb1.Find(ctx, db)
	assert.Nil(t, err)

	uuid1, err := uuid.Parse(lb1.Object.ID.String())
	assert.Nil(t, err)
	assert.Len(t, uuid1.String(), 36)

	err = lb1.Delete(ctx, db)
	assert.Nil(t, err)
}
