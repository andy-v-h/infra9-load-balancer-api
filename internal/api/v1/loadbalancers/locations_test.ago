// Package locations provides a the CRUD operations for locations
package loadbalancers

import (
	"context"
	"errors"
	"net/http"
	"testing"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/volatiletech/null/v8"
	"go.uber.org/zap"

	"go.infratographer.com/loadbalancerapi/internal/dbtools"
	"go.infratographer.com/loadbalancerapi/internal/httptools"
	"go.infratographer.com/loadbalancerapi/internal/models"
	errorsx "go.infratographer.com/loadbalancerapi/pkg/api/v1/errors"
	"go.infratographer.com/loadbalancerapi/pkg/api/v1/types"
)

func init() {
	SetLogger(zap.NewNop().Sugar())
}

var (
	errInvalidUUID = errors.New("invalid UUID length: 7")
)

func TestNewLocation(t *testing.T) {
	tenantID := uuid.New()
	happyPathBody := `{"display_name": "Nemo", "tenant_id": "` + tenantID.String() + `"}`
	missingTenantIDBody := `{"display_name": "Nemo"}`
	missingDisplayNameBody := `{"tenant_id": "` + tenantID.String() + `"}`
	invalidUUIDBody := `{"display_name": "Nemo", "tenant_id": "1234567"}`
	badBody := "bad body"

	type args struct {
		c *gin.Context
	}

	tests := []struct {
		name    string
		args    args
		want    *Location
		wantErr bool
		err     error
	}{
		{
			name: "Happy path",
			args: args{
				c: &[]gin.Context{
					{
						Request: &http.Request{
							Body: httptools.FakeBody(happyPathBody),
						},
					},
				}[0],
			},
			want: &Location{
				Object: &types.Location{
					TenantID: tenantID,
					Name:     "Nemo",
				},
			},
			wantErr: false,
		},
		{
			name: "Missing tenant ID",
			args: args{
				c: &[]gin.Context{
					{
						Request: &http.Request{
							Body: httptools.FakeBody(missingTenantIDBody),
						},
					},
				}[0],
			},
			wantErr: true,
			err:     errorsx.ErrTenantIDRequired,
		},
		{
			name: "Missing display name",
			args: args{
				c: &[]gin.Context{
					{
						Request: &http.Request{
							Body: httptools.FakeBody(missingDisplayNameBody),
						},
					},
				}[0],
			},
			wantErr: true,
			err:     errorsx.ErrNameRequired,
		},
		{
			name: "Invalid tenant ID",
			args: args{
				c: &[]gin.Context{
					{
						Request: &http.Request{
							Body: httptools.FakeBody(invalidUUIDBody),
						},
					},
				}[0],
			},
			wantErr: true,
			err:     errInvalidUUID,
		},
		{
			name: "Bad body",
			args: args{
				c: &[]gin.Context{
					{
						Request: &http.Request{
							Body: httptools.FakeBody(badBody),
						},
					},
				}[0],
			},
			// encoding/json implements its own SyntaxError type, so we can't use it here.
			err:     errors.New("invalid character 'b' looking for beginning of value"), //nolint:goerr113
			wantErr: true,
		},
	}

	for _, tt := range tests {
		got, err := NewLocation(tt.args.c)
		if tt.wantErr {
			assert.NotNil(t, err)
			assert.ErrorContains(t, err, tt.err.Error())
		} else {
			assert.Nil(t, err)
			assert.Equal(t, tt.want, got)
		}
	}
}

func TestLocation_ToDBModel(t *testing.T) {
	locationID := uuid.New()
	now := time.Now()
	tenantID := uuid.New()

	type fields struct {
		CreatedAt time.Time
		UpdatedAt time.Time
		DeletedAt *null.Time
		ID        uuid.UUID
		TenantID  uuid.UUID
		Name      string
	}

	tests := []struct {
		name    string
		fields  fields
		want    *models.Location
		wantErr bool
		err     error
	}{
		{
			name: "Happy path",
			fields: fields{
				CreatedAt: now,
				UpdatedAt: now,
				DeletedAt: &null.Time{},
				TenantID:  tenantID,
				Name:      "Nemo",
			},
			want: &models.Location{
				CreatedAt:   now,
				UpdatedAt:   now,
				DeletedAt:   null.Time{},
				LocationID:  locationID.String(),
				TenantID:    tenantID.String(),
				DisplayName: "Nemo",
			},
			wantErr: false,
		},
		{
			name: "Missing tenant ID",
			fields: fields{
				Name: "Nemo",
			},
			wantErr: true,
			err:     errorsx.ErrTenantIDRequired,
		},
		{
			name: "Missing display name",
			fields: fields{
				TenantID: tenantID,
			},
			wantErr: true,
			err:     errorsx.ErrNameRequired,
		},
	}
	for _, tt := range tests {
		l := &Location{
			&types.Location{
				CreatedAt: tt.fields.CreatedAt,
				UpdatedAt: tt.fields.UpdatedAt,
				DeletedAt: tt.fields.DeletedAt,
				ID:        tt.fields.ID,
				TenantID:  tt.fields.TenantID,
				Name:      tt.fields.Name,
			},
		}

		got, err := l.ToDBModel()
		if tt.wantErr {
			assert.NotNil(t, err)
			assert.ErrorContains(t, err, tt.err.Error())
		} else {
			assert.Nil(t, err)
			assert.Equal(t, tt.want.TenantID, got.TenantID)
			assert.Equal(t, tt.want.DisplayName, got.DisplayName)
		}
	}
}

func TestLocation_DB(t *testing.T) {
	ctx := context.Background()
	db := dbtools.DatabaseTest(t)

	loc1, loc1CleanUp := CreateTestLocation(t, db)
	defer loc1CleanUp()

	err := loc1.Find(ctx, db)
	assert.Nil(t, err)

	uuid1, err := uuid.Parse(loc1.Object.ID.String())
	assert.Nil(t, err)
	assert.Len(t, uuid1.String(), 36)

	locArray, err := GetLocations(ctx, db, loc1.Object.TenantID)
	assert.Nil(t, err)
	assert.Len(t, locArray, 1)

	err = loc1.Delete(ctx, db)
	assert.Nil(t, err)
}
